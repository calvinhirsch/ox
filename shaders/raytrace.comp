#version 460
#extension GL_EXT_scalar_block_layout : enable

const uint N_BOUNCES = 5;
const uint N_CASTS = 5;
const uint CHUNK_SIZE = 8;  // Number of blocks in each chunk level
const uint N_CHUNK_LVLS = 2;  // 2 means there are two chunk sizes (CHUNK_SIZE and CHUNK_SIZE**2) where the largest chunk size is the world height
const uint RENDER_N_TLCHUNKS = 4;  // Render THIS x THIS top level chunks around player (assuming world is only 1 top level chunk high)
const uint CHUNK_LVL_BLOCK_SIZE[N_CHUNK_LVLS+2] = {1, CHUNK_SIZE, CHUNK_SIZE*CHUNK_SIZE, 99999999};  // Chunk level 0 means working directly with blocks (i.e. size of 1)
const uint BITMASK_IDX[32] = {1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 1073741824, 2147483648};
const uint N_CHUNKS[N_CHUNK_LVLS+1] = {
        CHUNK_SIZE*CHUNK_SIZE*CHUNK_SIZE*CHUNK_SIZE*CHUNK_SIZE*CHUNK_SIZE*RENDER_N_TLCHUNKS*RENDER_N_TLCHUNKS,
        CHUNK_SIZE*CHUNK_SIZE*CHUNK_SIZE*RENDER_N_TLCHUNKS*RENDER_N_TLCHUNKS,
        RENDER_N_TLCHUNKS*RENDER_N_TLCHUNKS,
};
const uint N_MATERIAL_ID_BITS = 8;
const uint MATERIALS_PER_VEC4 = 128 / N_MATERIAL_ID_BITS;
const uint MATERIALS_PER_INT = 32 / N_MATERIAL_ID_BITS;
const uint N_MATERIALS = 1 << N_MATERIAL_ID_BITS;

const float MAX_SUN_EMISSION = 1.5;
const float MIN_SUM_EMISSION = 0.75;
const vec3 SUN_COLOR = vec3(1.0, 0.98, 0.9);
const vec3 SKY_COLOR = vec3(0.6, 0.78, 0.98);


// Output image
layout (set = 0, binding = 0) writeonly uniform image2D image;

struct Material {
    vec3 color;
    vec3 specular_color;
    vec3 emission_color;
    float emission_strength;  // [0,1]
    float specular_prob;  // [0,1]
};
// Constant material buffer
layout (set = 0, binding = 1, scalar) uniform MaterialS {
    Material defs[4];
} materials;

layout (set = 0, binding = 2, scalar) readonly uniform Camera {
    vec3 eye;
    vec3 viewport_center;
    vec3 right_dir;
    vec3 up_dir;
} camera;

// Uniform buffer object that holds all other info that gets updated every frame
layout (set = 0, binding = 3, scalar) readonly uniform UBO {
    vec3 sun_dir;
    int tlc_minxi;
    int tlc_minzi;
    uint time;
} ubo;

// Top level chunks are randomly ordered in memory to avoid mass copying. So this is a mapping from expected index
// (where index = X + Z * RENDER_N_TLCHUNKS) to actual index
layout (set = 0, binding = 4, scalar) readonly uniform TopLevelChunkIndices {
    uvec4 indices[RENDER_N_TLCHUNKS*RENDER_N_TLCHUNKS/4];
} tlci;

// Material IDs for each voxel
layout (set = 0, binding = 5, scalar) readonly buffer MaterialIndex {
    uvec4 indices[N_CHUNKS[0] * N_MATERIAL_ID_BITS / 128];
} voxel_material_ids;

// Chunk bitmasks at each chunk level
layout (set = 0, binding = 6, scalar) readonly buffer VoxelBitmask0 {
    uvec4 mask[uint((N_CHUNKS[0] + 127) / 128)];
} chunk_bitmasks0;

layout (set = 0, binding = 7, scalar) readonly buffer VoxelBitmask1 {
    uvec4 mask[uint((N_CHUNKS[1] + 127) / 128)];
} chunk_bitmasks1;

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;


ivec3 amod (ivec3 v, uint m) {
    return ivec3(((v % m) + m) % m);
}


// RNG

// www.pcg-random.org and www.shadertoy.com/view/XlGcRh
uint next_rand(inout uint state) {
    state = state * 747796405 + 2891336453;
    uint result = ((state >> ((state >> 28) + 4)) ^ state) * 277803737;
    result = (result >> 22) ^ result;
    return result;
}

float rand(inout uint state) {
    // Uniformly random in [0, 1]
    return float(next_rand(state)) / 4294967295.0;
}

float rand_normal(inout uint state) {
    // Random value sampled from normal distribution (https://stackoverflow.com/a/6178290)
    float theta = 2.0 * 3.1415926 * rand(state);
    float rho = sqrt(float(-2 * log(rand(state))));
    return rho * cos(theta);
}

vec3 rand_dir(inout uint state) {
    return normalize(vec3(rand_normal(state), rand_normal(state), rand_normal(state)));
}


// Ray tracing utils

// Keeps track of current block/chunk at all levels (level 0 is a voxel position relative to lvl 1 chunk, level 1 is a
// chunk position (in units of CHUNK_SIZE) relative to lvl2 chunk, lvl 2 chunk is chunk position (in units of
// CHUNK_SIZE^2) relative to lvl3 chunk, etc.)
// TODO: I don't understand why vec3 block[...] doesn't work, this is a workaround. Might be a better way.
int block[N_CHUNK_LVLS+1][3];

ivec3 abs_block(uint lvl) {
    // Get the absolute position of the current block at lvl in lvl units
    ivec3 pt = ivec3(block[N_CHUNK_LVLS][0], block[N_CHUNK_LVLS][1], block[N_CHUNK_LVLS][2]);
    if (lvl == 2) {
        return pt;
    }
    for (int lvli = int(N_CHUNK_LVLS)-1; lvli >= lvl; lvli--) {
        pt *= int(CHUNK_SIZE);
        pt += ivec3(block[lvli][0], block[lvli][1], block[lvli][2]);
    }

    return pt;
}

void set_block_tlc(vec3 ray_origin) {
    ivec3 tlc = ivec3(floor(ray_origin / CHUNK_LVL_BLOCK_SIZE[N_CHUNK_LVLS]));
    block[N_CHUNK_LVLS][0] = tlc.x;
    block[N_CHUNK_LVLS][1] = tlc.y;
    block[N_CHUNK_LVLS][2] = tlc.z;
}

void set_block_all_lvls(vec3 ray_origin, uint at_lvl_and_below) {
    if (at_lvl_and_below >= N_CHUNK_LVLS) {
        set_block_tlc(ray_origin);
    }

    ivec3 pt = ivec3(block[N_CHUNK_LVLS][0], block[N_CHUNK_LVLS][1], block[N_CHUNK_LVLS][2]);
    for (int lvli = int(N_CHUNK_LVLS-1); lvli >= 0; lvli--) {
        pt *= int(CHUNK_SIZE);

        if (lvli <= at_lvl_and_below) {
            ivec3 pti = clamp(ivec3(floor(ray_origin / CHUNK_LVL_BLOCK_SIZE[lvli])) - pt, ivec3(0), ivec3(int(CHUNK_SIZE - 1)));
            pt += pti;
            block[lvli][0] = pti.x;
            block[lvli][1] = pti.y;
            block[lvli][2] = pti.z;
        }
        else {
            pt += ivec3(block[lvli][0], block[lvli][1], block[lvli][2]);
        }
    }
}

void step_block(uint ax, float ax_dir, uint lvl) {
    // Step the block in ax_dir direction along ax at lvl
    // If this will cross the boundary of a higher level chunk (i.e. block pos in ax < 0 or > CHUNK_SIZE
    int incr;
    int val;
    if (ax_dir > 0) {
        incr = 1;
        val = 0;
    }
    else {
        incr = -1;
        val = int(CHUNK_SIZE)-1;
    }

    block[lvl][ax] += incr;
    for (uint lvli = lvl; lvli < N_CHUNK_LVLS && (block[lvli][ax] == -1 || block[lvli][ax] == CHUNK_SIZE); lvli++) {
        block[lvli+1][ax] += incr;
        block[lvli][ax] = val;
    }
    for (int lvli = int(lvl) - 1; lvli >= 0; lvli--) {
        block[lvli][ax] = val;
    }
}

uint block_index(uint lvl) {
    if (lvl == N_CHUNK_LVLS) {
        uint idx_to_look_up = (
            block[lvl][0] +
            block[lvl][1] * RENDER_N_TLCHUNKS * RENDER_N_TLCHUNKS +
            block[lvl][2] * RENDER_N_TLCHUNKS
        );
        return tlci.indices[idx_to_look_up/4][idx_to_look_up%4];
    }
    return block[lvl][0] + block[lvl][1] * CHUNK_SIZE * CHUNK_SIZE + block[lvl][2] * CHUNK_SIZE;
}

uint chunk_botleft_index(uint lvl) {
    // Get the index of the bottom left block of a chunk at lvl
    uint idx = block_index(N_CHUNK_LVLS);
    for (uint lvli = N_CHUNK_LVLS-1; lvli > lvl; lvli--) {
        idx *= CHUNK_SIZE*CHUNK_SIZE*CHUNK_SIZE;
        idx += block_index(lvli);
    }

    return idx * CHUNK_SIZE*CHUNK_SIZE*CHUNK_SIZE;
}

ivec3 chunk_abs_botleft_block(uint lvl) {
    // Get the absolute position of the bottom left of the current chunk at lvl+1 in units of the current lvl
    if (lvl == 2) {
        return ivec3(0, 0, 0);
    }
    return abs_block(lvl+1) * int(CHUNK_SIZE);
}

bool is_true_in_mask(uint idx, uint lvl) {
    if (lvl == N_CHUNK_LVLS) { return true; }
    if (lvl == 0) { return (chunk_bitmasks0.mask[idx / 128][(idx / 32) % 4] & (0x0001 << (idx % 32))) > 0; }
    return (chunk_bitmasks1.mask[idx / 128][(idx / 32) % 4] & (0x0001 << (idx % 32))) > 0;
}

uint grid_index(uint ai, uint bi, uint ci, uint ax_a, uint ax_b, uint ax_c, uint lvl) {
    // Returns index within the current chunk. Expects ai, bi, ci to be 0 <= value < CHUNK_SIZE for non-TL chunks
    // and returns a value between 0 and CHUNK_SIZE^3
    // For top level chunks, returns a value between 0 and RENDER_N_TLCHUNKS*RENDER_N_TLCHUNKS
    uvec3 idx;
    idx[ax_a] = ai;
    idx[ax_b] = bi;
    idx[ax_c] = ci;

    if (lvl == N_CHUNK_LVLS) {
        idx.x -= ubo.tlc_minxi;
        idx.z -= ubo.tlc_minzi;
    }

    // Indexing scheme is x + y * N^2 + z * N so that array for top level chunks (which have y length = 1) is contiguous
    return idx.x + idx.y * CHUNK_SIZE * CHUNK_SIZE + idx.z * CHUNK_SIZE;
}

uint material_id_at_voxel_index(uint voxel_idx) {
    uvec4 mv4 = voxel_material_ids.indices[voxel_idx / MATERIALS_PER_VEC4];
    uint subidx = (voxel_idx % MATERIALS_PER_VEC4) / MATERIALS_PER_INT;
    uint mint = mv4[subidx];
    // N_MATERIAL_ID_BITS-bit int embedded in 32-bit int (mint)
    // Shift left to get rid of data to the left and then right to scale it properly
    return (mint << (32 - (subidx+1)*N_MATERIAL_ID_BITS)) >> (32 - N_MATERIAL_ID_BITS);
}

Material material_at_voxel_index(uint voxel_idx) {
    uint id = material_id_at_voxel_index(voxel_idx);
    return materials.defs[id];
}

void set_ray_pos_on_bc_intersect(inout vec3 ray_origin, uint crossed_ax, uint other_ax, uint ax_a, uint ai, int a_neg, uint crossed_ax_i, float crossed_ax_p, uint crossed_ax_neg, float other_ax_p, float crossed_d_da, float other_d_da, uint lvl) {
    ray_origin[crossed_ax] += crossed_ax_i + crossed_ax_neg;
    // Amount we have to rewind a to get crossed_ax to the point where it crossed the border
    float da = (crossed_ax_i + crossed_ax_neg - crossed_ax_p) / crossed_d_da;
    ray_origin[ax_a] += ai + a_neg + da;  // if a has negative direction, add 1 to get to upper side of the block
    ray_origin[other_ax] += other_ax_p + da * other_d_da;
    ray_origin *= CHUNK_LVL_BLOCK_SIZE[lvl];
}

void bounce_ray(inout vec3 ray_dir, uint reflect_ax, inout vec3 color, inout vec3 light, inout uint rand_state, uint voxel_idx, vec3 normal) {
    Material m = material_at_voxel_index(voxel_idx);

    light += m.emission_color * m.emission_strength * color;

    if (rand(rand_state) < m.specular_prob) {
        ray_dir[reflect_ax] *= -1;
        color *= m.specular_color;
    }
    else {
        ray_dir = normalize(normal + rand_dir(rand_state));
        color *= m.color;
    }
}


vec3 trace_ray(vec3 ray_origin, vec3 ray_dir, inout uint rand_state) {
    vec3 color = vec3(1, 1, 1);
    vec3 light = vec3(0, 0, 0);
    int lvl = 0;  // current chunk level
    uint crossed_ax = 0;

    // Set the 'block' array based on starting position
    set_block_all_lvls(ray_origin, N_CHUNK_LVLS);

    float strength_TEMP = 0; // TEMP

    // Trace ray over N_BOUNCES
    int bounce = 0;
    for (int safety_limit = 0; safety_limit < 100 && bounce < N_BOUNCES; safety_limit++) {
        uint chunk_botleft_idx = chunk_botleft_index(lvl);
        ivec3 chunk_botleft_blk = chunk_abs_botleft_block(lvl);

        // Establish search boundaries based on current chunk lvl

        ivec3 min_pt = ivec3(-1, -1, -1);
        ivec3 max_pt;

        if (lvl == N_CHUNK_LVLS) {
            max_pt = ivec3(RENDER_N_TLCHUNKS, 1, RENDER_N_TLCHUNKS);
        }
        else {
            max_pt = ivec3(int(CHUNK_SIZE), int(CHUNK_SIZE), int(CHUNK_SIZE));
        }

        // Get absolute and relative position
        vec3 abs_pos = ray_origin / CHUNK_LVL_BLOCK_SIZE[lvl];
        vec3 pos = abs_pos - chunk_botleft_blk;  // Same units as block[lvl] but specific float position rather than int position of block we are currently at

        //////////////////////////////
        // Search for intersections //
        //////////////////////////////

        // Identify axis (x, y, or z) the ray is most parallel to and set to axis A
        uint ax_a = 0;
        uint ax_b = 1;
        uint ax_c = 2;
        float highest = abs(ray_dir.x);

        if (abs(ray_dir.y) > highest) {
            highest = abs(ray_dir.y);
            ax_a = 1;
            ax_b = 2;
            ax_c = 0;
        }
        if (abs(ray_dir.z) > highest) {
            highest = abs(ray_dir.z);
            ax_a = 2;
            ax_b = 0;
            ax_c = 1;
        }

        // Traverse grid until hit a present voxel (a true value in the bitmask)

        int a_dir = ray_dir[ax_a] > 0 ? 1 : -1;
        int a_neg = int(a_dir < 0);
        int ai = block[lvl][ax_a];
        float a_normal_dir = -float(a_dir);
        // ray_origin should be within the bounds of block[lvl][ax_a] (AKA ai) or else something else has messed up.
        // So, a_floored_amt should always be <= 1
        // Also, if a_dir is negative then we need to add 1 because we are at the 'top' (larger a) side of block ai
        float a_floored_amt = pos[ax_a] - (ai + a_neg);

        float db_da = ray_dir[ax_b] / ray_dir[ax_a];
        float dc_da = ray_dir[ax_c] / ray_dir[ax_a];
        int b_neg = int(ray_dir[ax_b] < 0);
        int c_neg = int(ray_dir[ax_c] < 0);
        float b_normal_dir = bool(b_neg) ? 1 : -1;
        float c_normal_dir = bool(c_neg) ? 1 : -1;

        float b = pos[ax_b] - db_da * a_floored_amt;
        int bi = block[lvl][ax_b];
        float last_b = b;
        int last_bi = int(floor(last_b));
        float c = pos[ax_c] - dc_da * a_floored_amt;
        int ci = block[lvl][ax_c];
        float last_c = c;
        int last_ci = int(floor(last_c));

        ///////////////////////  DEBUG  ///////////////////////////
        // Don't care to check these things if we are out of bounds
        if (ai < 0 || ai >= CHUNK_SIZE) {
            return vec3(0, 0, 1) * (lvl + 1) / 3.0;
        }
        if (bi < 0 || bi >= CHUNK_SIZE) {
            return vec3(0, 0, 1) * (lvl + 1) / 3.0;
        }
        if (ci < 0 || ci >= CHUNK_SIZE) {
            return vec3(0, 0, 1) * (lvl + 1) / 3.0;
        }

        if ((abs(a_floored_amt) > 1.01) || (abs(pos[ax_b] - (block[lvl][ax_b] + b_neg)) > 1.01) || (abs(pos[ax_c] - (block[lvl][ax_c] + c_neg)) > 1.01)) {
            return vec3(1, 0, 0.3);
        }
        ///////////////////////   END   ///////////////////////////

        bool hit = false;
        uint rel_idx;
        uint global_idx;
        uint reflect_axis;
        vec3 normal = vec3(0, 0, 0);
        bool c_ib;
        bool b_ib;
        uint oob_ax = ax_a;

        // All branches set a new ray_origin and would start by doing this, so pulled it out and put it here.
        ray_origin = vec3(chunk_botleft_blk);

        // Process the block we start in (this is a special case where we need to check how we got here)
        if (crossed_ax == ax_a) {
            // Don't need to do anything, first iteration will do the right thing
        }
        else {
            rel_idx = grid_index(ai, bi, ci, ax_a, ax_b, ax_c, lvl);
            global_idx = chunk_botleft_idx + rel_idx;
            if (is_true_in_mask(global_idx, lvl)) {
                // Hit!
                hit = true;

                if (crossed_ax == ax_b) {
                    reflect_axis = ax_b;
                    crossed_ax = ax_b;
                    normal[ax_b] = b_normal_dir;
                    set_ray_pos_on_bc_intersect(ray_origin, ax_b, ax_c, ax_a, ai, a_neg, bi, b, b_neg, c, db_da, dc_da, lvl);
                }
                else {
                    reflect_axis = ax_c;
                    crossed_ax = ax_c;
                    normal[ax_c] = c_normal_dir;
                    set_ray_pos_on_bc_intersect(ray_origin, ax_c, ax_b, ax_a, ai, a_neg, ci, c, c_neg, b, dc_da, db_da, lvl);
                }
            }
            else {
                // We already checked the first block so step forward one
                last_bi = bi;
                last_ci = ci;
                last_b = b;
                last_c = c;

                ai += a_dir;
                b += db_da * a_dir;
                c += dc_da * a_dir;
                bi = int(floor(b));
                ci = int(floor(c));
            }
        }

        // If we didn't hit the starting block and we are in bounds of top level chunks, search all other intersecting blocks
        // March ray with step size that increases value for axis a by 1 each step
        if (!hit) {
            for (; ai <= max_pt[ax_a] && ai >= min_pt[ax_a]; ai += a_dir) {
                strength_TEMP += 1.0 / 12; // TEMP

                bool b_crossed = bi != last_bi;
                bool c_crossed = ci != last_ci;
                b_ib = bi < max_pt[ax_b] && bi > min_pt[ax_b];  // is b still in bounds
                c_ib = ci < max_pt[ax_c] && ci > min_pt[ax_c];  // is c still in bounds

                bool b_first;

                // Check first possible voxel location, in the case where we cross all three axes, the first voxel
                // intersected is determined by which axis we cross first.
                if (b_crossed && c_crossed) {
                    // Whether crossed axis b before crossing axis c, if true check intersect voxel [a-a_dir, bi, last_ci] else [a-a_dir, last_bi, ci]
                    b_first = abs((bi + b_neg - last_b) / db_da) < abs((ci + c_neg - last_c) / dc_da);
                    if ((b_first && b_ib) || (!b_first && c_ib)) {
                        rel_idx = grid_index(ai - a_dir, b_first ? bi : last_bi, b_first ? last_ci : ci, ax_a, ax_b, ax_c, lvl);
                        global_idx = chunk_botleft_idx + rel_idx;

                        if (is_true_in_mask(global_idx, lvl)) {
                            // Hit!
                            hit = true;

                            // Update ray_origin for hit point
                            block[lvl][ax_a] = ai - a_dir;
                            if (b_first) {
                                // [a-a_dir, bi, last_ci], crossed b
                                normal[ax_b] = b_normal_dir;
                                crossed_ax = ax_b;
                                reflect_axis = ax_b;
                                set_ray_pos_on_bc_intersect(ray_origin, ax_b, ax_c, ax_a, ai, a_neg, bi, b, b_neg, c, db_da, dc_da, lvl);
                                block[lvl][ax_b] = bi;
                                block[lvl][ax_c] = last_ci;
                            }
                            else {
                                // [a-a_dir, last_bi, ci], crossed c
                                normal[ax_c] = c_normal_dir;
                                crossed_ax = ax_c;
                                reflect_axis = ax_c;
                                set_ray_pos_on_bc_intersect(ray_origin, ax_c, ax_b, ax_a, ai, a_neg, ci, c, c_neg, b, dc_da, db_da, lvl);
                                block[lvl][ax_b] = last_bi;
                                block[lvl][ax_c] = ci;
                            }
                            if (lvl > 0) {
                                set_block_all_lvls(ray_origin, lvl - 1);
                            }

                            break;
                        }
                    }
                }
                else if (b_crossed) { b_first = false; }
                else if (c_crossed) { b_first = true; }

                // If we went out of bounds in either b axis or c axiz, set ray pos to where it crossed and break
                if (!b_ib && (c_ib || !c_crossed || b_first)) {
                    set_ray_pos_on_bc_intersect(ray_origin, ax_b, ax_c, ax_a, ai, a_neg, bi, b, b_neg, c, db_da, dc_da, lvl);
                    oob_ax = ax_b;
                    crossed_ax = ax_b;
                    break;
                }
                if (!c_ib) {
                    set_ray_pos_on_bc_intersect(ray_origin, ax_c, ax_b, ax_a, ai, a_neg, ci, c, c_neg, b, dc_da, db_da, lvl);
                    oob_ax = ax_c;
                    crossed_ax = ax_c;
                    break;
                }

                if (b_crossed || c_crossed) {
                    // check intersect voxel [a-a_dir, bi, ci]
                    rel_idx = grid_index(ai - a_dir, bi, ci, ax_a, ax_b, ax_c, lvl);
                    global_idx = chunk_botleft_idx + rel_idx;

                    if (is_true_in_mask(global_idx, lvl)) {
                        // Hit!
                        hit = true;

                        // Update ray_origin for hit point
                        // Reusing b_first here (with augmented meaning) to determine which axis was crossed for this check.
                        if (b_first) {
                            // crossed c
                            crossed_ax = ax_c;
                            reflect_axis = ax_c;
                            normal[ax_c] = c_normal_dir;
                            set_ray_pos_on_bc_intersect(ray_origin, ax_c, ax_b, ax_a, ai, a_neg, ci, c, c_neg, b, dc_da, db_da, lvl);
                        }
                        else {
                            // crossed b
                            crossed_ax = ax_b;
                            reflect_axis = ax_b;
                            normal[ax_b] = b_normal_dir;
                            set_ray_pos_on_bc_intersect(ray_origin, ax_b, ax_c, ax_a, ai, a_neg, bi, b, b_neg, c, db_da, dc_da, lvl);
                        }
                        block[lvl][ax_a] = ai - a_dir;
                        block[lvl][ax_b] = bi;
                        block[lvl][ax_c] = ci;
                        if (lvl > 0) {
                            set_block_all_lvls(ray_origin, lvl - 1);
                        }

                        break;
                    }
                }

                if (ai < max_pt[ax_a] && ai > min_pt[ax_a]) {
                    // check intersect voxel [ai, bi, ci]

                    rel_idx = grid_index(ai, bi, ci, ax_a, ax_b, ax_c, lvl);
                    global_idx = chunk_botleft_idx + rel_idx;

                    if (is_true_in_mask(global_idx, lvl)) {
                        // Hit!
                        hit = true;

                        reflect_axis = ax_a;
                        normal[ax_a] = a_normal_dir;
                        crossed_ax = ax_a;
                        ray_origin[ax_a] += ai + a_neg;
                        ray_origin[ax_b] += b;
                        ray_origin[ax_c] += c;
                        ray_origin *= CHUNK_LVL_BLOCK_SIZE[lvl];

                        block[lvl][ax_a] = ai;
                        block[lvl][ax_b] = bi;
                        block[lvl][ax_c] = ci;

                        if (lvl > 0) {
                            set_block_all_lvls(ray_origin, lvl - 1);
                        }

                        break;
                    }
                }

                last_bi = bi;
                last_ci = ci;
                last_b = b;
                last_c = c;

                b += db_da * a_dir;
                c += dc_da * a_dir;
                bi = int(floor(b));
                ci = int(floor(c));
            }
        }

        bool hit_skybox = false;

        if (hit) {
            // Hit a block -- ray position and block already set
            if (lvl > 0) {
                lvl--;
            }
            else {
                // When we are at lvl == 0, global_idx is an individual voxel index (rather than a subchunk at higher lvls)
//                return vec3((global_idx % 64) / 64.0);
                bounce_ray(ray_dir, reflect_axis, color, light, rand_state, global_idx, normal);

                // Currently, 'block' is indicating the voxel we just bounced off of. Step it towards the direction
                // we are reflecting to
                step_block(reflect_axis, ray_dir[reflect_axis], lvl);

                bounce++;
            }
        }
        else {
            // Did not hit any blocks in this chunk
            if (lvl < N_CHUNK_LVLS) {
                // We hit nothing in this subchunk, go back to higher level chunk
                // (ray position and block have not yet been updated)
                // TOOD: Check if we can skip a level and go up 2

                if (oob_ax == ax_a) {
                    // We reached the back of the chunk without crossing b or c axis chunk borders.
                    // Need to roll back by an ai=1 step because we passed max_pt or min_pt and didn't update b/c on the
                    // last step.
                    ai -= a_dir;
                    b -= db_da * a_dir;
                    c -= dc_da * a_dir;

                    crossed_ax = ax_a;

                    ray_origin[ax_a] += ai + a_neg;
                    ray_origin[ax_b] += b;
                    ray_origin[ax_c] += c;
                    ray_origin *= CHUNK_LVL_BLOCK_SIZE[lvl];
                    // If this is false, then we already set ray_origin.
                }

                // Set block based on new ray_origin position
                set_block_all_lvls(ray_origin, lvl+1);
                // ray_origin will be near a border on oob_ax so make sure the block is the right one and we don't check
                // this same chunk again, leading to an infinite loop
                if ((ray_dir[oob_ax] > 0 && block[lvl][oob_ax] == CHUNK_SIZE-1) || (ray_dir[oob_ax] < 0 && block[lvl][oob_ax] == 0)) {
                    step_block(oob_ax, ray_dir[oob_ax], lvl);
                }
                lvl++;

                if (block[2][0] < 0 || block[2][0] >= RENDER_N_TLCHUNKS || block[2][1] < 0 || block[2][1] >= 1 || block[2][2] < 0 || block[2][2] >= RENDER_N_TLCHUNKS) {
                    hit_skybox = true;
                }

                ///////////////////////  DEBUG  ///////////////////////////
                else {
                    vec3 diff = abs(ray_origin / CHUNK_LVL_BLOCK_SIZE[lvl] - abs_block(lvl));
                    if (diff.x > 1.01) {
                        return vec3(1, 0.6, 0);
                    }
                    if (diff.y > 1.01) {
                        return vec3(1, 0.6, 0);
                    }
                    if (diff.z > 1.01) {
                        return vec3(1, 0.6, 0);
                    }
                }
                ///////////////////////   END   ///////////////////////////
            }
            else {
                hit_skybox = true;
            }
        }

        if (hit_skybox) {
            float d = dot(ray_dir, ubo.sun_dir);
            float strength = (d + 1) / 2 * (MAX_SUN_EMISSION - MIN_SUM_EMISSION) + MIN_SUM_EMISSION;
            light += strength * (d > 0.999 ? SUN_COLOR : SKY_COLOR) * color;
            return light;
        }
    }

    if (bounce < 10) {
        return vec3(1, 0, 0);
    }

    return light;
}


void main() {
    vec3 light = vec3(0, 0, 0);
    ivec2 win_size = imageSize(image);

    // TEMP ACCESS ALL THE BOUND STRUCTS
    Material a = materials.defs[0];
    uint e = voxel_material_ids.indices[0][0];
    vec3 eye = camera.eye;
    uint x = ubo.tlc_minxi;
    uvec4 tlc = tlci.indices[0];
    uvec4 b = chunk_bitmasks0.mask[0];
    uvec4 c = chunk_bitmasks1.mask[0];
    // END

    if (gl_GlobalInvocationID.x >= win_size.x || gl_GlobalInvocationID.y >= win_size.y) { return; }

    const vec2 uv = (vec2(gl_GlobalInvocationID.xy) / vec2(win_size)) * 2.0 - 1.0;

    for (uint cast_i = 0; cast_i < N_CASTS; cast_i++) {
        uint rand_state = gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * win_size.x + (ubo.time + cast_i) * win_size.x * win_size.y;
        // TODO: Randomly offset u, v based on random_seed

        vec3 ray_origin = camera.viewport_center + camera.right_dir * uv.x + camera.up_dir * -uv.y;
        vec3 ray_dir = normalize(ray_origin - camera.eye);
        // Put ray origin into coords with origin at botleft of loaded area
        ray_origin -= vec3(ubo.tlc_minxi, 0, ubo.tlc_minzi) * CHUNK_LVL_BLOCK_SIZE[N_CHUNK_LVLS];

        light += trace_ray(ray_origin, ray_dir, rand_state);
    }

    light /= float(N_CASTS);
    imageStore(image, ivec2(gl_GlobalInvocationID.xy), vec4(light, 1));
}